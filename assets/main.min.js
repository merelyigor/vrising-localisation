/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/scss/style.scss":
/*!*****************************!*\
  !*** ./src/scss/style.scss ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack:///./src/scss/style.scss?");

/***/ }),

/***/ "./src/css/style.css":
/*!***************************!*\
  !*** ./src/css/style.css ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack:///./src/css/style.css?");

/***/ }),

/***/ "./src/js/main.js":
/*!************************!*\
  !*** ./src/js/main.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _css_style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../css/style.css */ \"./src/css/style.css\");\n/* harmony import */ var _scss_style_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scss/style.scss */ \"./src/scss/style.scss\");\n\n\n// # npm run build\n// # npm run watch\n\n(function () {\n    let allFileStrings = {};\n    let mainLocalizationArr = [];\n    let fileUrl = null;\n    const MAX_CONCURRENT_REQUESTS = 40;\n    const downloadLink = document.getElementById('downloadLink');\n    const downloadButtonServerWrap = document.querySelector('.download-json-server-wrap');\n    const downloadButtonServer = document.querySelector('.download-json-server');\n    const localStorageJson = localStorage.getItem('mainLocalizationArr');\n\n    if (localStorageJson && localStorageJson.length > 100) {\n        downloadLink.style.display = 'flex';\n\n        // Показуємо дату та час збереження, якщо вони є\n        const saveTime = localStorage.getItem('saveTime');\n        if (saveTime) {\n            document.getElementById('save-info-text').style.display = 'flex';\n            displaySaveTime(saveTime);\n        }\n    }\n\n    document.getElementById('toggleButton').addEventListener('click', function () {\n        const textBlock = document.getElementById('textBlock');\n        const toggleButton = this;\n\n        if (textBlock.classList.contains('expanded')) {\n            textBlock.classList.remove('expanded');\n            toggleButton.textContent = '→ Показати все ←';\n        } else {\n            textBlock.classList.add('expanded');\n            toggleButton.textContent = '→ Показати менше ←';\n        }\n    });\n\n    function displaySaveTime(saveTime) {\n        const saveTimeElement = document.getElementById('saveTime');\n        document.getElementById('save-info-text').style.display = 'flex';\n        if (saveTimeElement) {\n            saveTimeElement.textContent = `Файл вже було згенеровано вами раніше, та збережено: ${new Date(saveTime).toLocaleString()}`;\n        }\n    }\n\n    function showSpinner() {\n        const spinnerElement = document.querySelector('.spinner');\n        const spinnerContainerElement = document.querySelector('.container-spinner');\n        const spinnerContainerElementText = document.querySelector('.container-spinner-text');\n        if (spinnerElement) {\n            spinnerElement.style.display = 'flex';\n            spinnerContainerElement.style.display = 'flex';\n            spinnerContainerElementText.style.display = 'flex';\n        }\n    }\n\n    function hideSpinner() {\n        const spinnerElement = document.querySelector('.spinner');\n        const spinnerContainerElement = document.querySelector('.container-spinner');\n        if (spinnerElement) {\n            spinnerElement.style.display = 'none';\n            spinnerContainerElement.style.display = 'none';\n        }\n    }\n\n    function updateTextProcessing(text) {\n        const textProcessingElement = document.querySelector('.text-processing');\n        if (textProcessingElement) {\n            textProcessingElement.innerHTML = text;\n        }\n    }\n\n    function updateProgressBar(completed, total) {\n        const progressBar = document.getElementById('progressBar');\n        const progressText = document.getElementById('progressText');\n        const percentage = Math.round((completed / total) * 100);\n        progressText.style.display = 'flex';\n\n        if (progressBar) {\n            progressBar.style.width = `${percentage}%`;\n        }\n        if (progressText) {\n            progressText.textContent = `${percentage}%`;\n        }\n    }\n\n    async function retryFetch(url, options = {}, retries = 300, delay = 1000) {\n        let errorTxt = document.querySelector('.text-processing');\n        for (let i = 0; i < retries; i++) {\n            try {\n                const response = await fetch(url, options);\n                if (!response.ok) throw new Error('Fetch error');\n                return response;\n            } catch (error) {\n                console.error(`Fetch error on attempt ${i + 1}: ${error.message}`);\n                if (i < retries - 1) {\n                    await new Promise(resolve => setTimeout(resolve, delay));\n                } else {\n                    // Вивід повідомлення про помилку після N спроб\n                    console.error('Error: Сервер не може надати відповідь!');\n                    console.error('Error: Перевищено максимальну кількість спроб на відповіді від серверу!');\n                    updateTextProcessing(`Сервер повернув занадто багато помилкових відповідей \n                    а саме більше ніж ${retries}.\n                    <br> Перевищено максимальну кількість спроб на відповіді від серверу!\n                    <br> Спробуйте перезавантажити сторінку та повторити генерацію заново.\n                    <span class=\"error\">!!!</span>`);\n                    errorTxt.style.color = '#ff0000';\n                    errorTxt.style.border = '5px solid #ff0000';\n                    errorTxt.classList.add('shake-element');\n                    throw error;\n                }\n            }\n        }\n    }\n\n    function startGeneration() {\n        showSpinner();\n        updateProgressBar(0, 10);\n        document.getElementById('downloadLink').style.display = 'none';\n        document.getElementById('save-info-text').style.display = 'none';\n\n        retryFetch('/?start-generation=1')\n            .then(response => response.json())\n            .then(files => {\n                let index = 0;\n                const totalFiles = files.length;\n                let completedFiles = 0;\n\n                function fetchNextFile() {\n                    if (index < files.length) {\n                        let file = files[index];\n                        processingStringAsFile(file.id, file.name)\n                            .then(strings => {\n                                allFileStrings[file.name] = strings;\n                                index++;\n                                completedFiles++;\n                                updateProgressBar(completedFiles, totalFiles); // Update progress bar\n                                fetchNextFile();\n                            })\n                            .catch(error => {\n                                console.error('Error fetching strings:', error);\n                            });\n                    } else {\n                        processAllFileStrings(allFileStrings, mainLocalizationArr).then(() => {\n                            saveJsonFile(mainLocalizationArr);\n                        }).catch(error => {\n                            console.error('Error processing all file strings:', error);\n                        });\n                    }\n                }\n\n                fetchNextFile();\n            })\n            .catch(error => {\n                console.error('Error fetching files:', error);\n            });\n    }\n\n    function processingStringAsFile(fileId, fileName, offset = 0, allStrings = []) {\n        updateTextProcessing(`Запитую усі ID рядків для файлу ${fileName}`);\n        return new Promise((resolve, reject) => {\n            retryFetch(`/?getAllStrings=all&fileId=${fileId}&offset=${offset}`)\n                .then(response => response.json())\n                .then(strings => {\n                    if (strings.length === 500) {\n                        offset = offset + strings.length;\n                        allStrings = allStrings.concat(strings);\n                        processingStringAsFile(fileId, fileName, offset, allStrings)\n                            .then(resolve)\n                            .catch(reject);\n                    } else {\n                        allStrings = allStrings.concat(strings);\n                        resolve(allStrings);\n                    }\n                })\n                .catch(error => {\n                    console.error('Error fetching strings:', error);\n                    reject(error);\n                });\n        });\n    }\n\n    function processingAllStringsTranslate(fileName, fileId, stringId, stringIdentifier, mainLocalizationArr) {\n        return new Promise((resolve, reject) => {\n            retryFetch(`/?translate=uk&fileId=${fileId}&stringId=${stringId}&stringIdentifier=${stringIdentifier}`)\n                .then(response => response.json())\n                .then(translation => {\n                    mainLocalizationArr.push({\n                        guid: translation.stringIdentifier,\n                        text: translation.text\n                    });\n                    updateTextProcessing(`Обробка перекладу для рядка ${translation.stringIdentifier} <br>\n                                                  у файлі ${fileName} <br>\n                                                  фраза: ${translation.text}`);\n                    resolve();\n                })\n                .catch(error => {\n                    console.error('Error fetching translation:', error);\n                    reject(error);\n                });\n        });\n    }\n\n    async function processAllFileStrings(allFileStrings, mainLocalizationArr) {\n        const promises = [];\n        const totalStrings = Object.values(allFileStrings).reduce((acc, val) => acc + val.length, 0);\n        let completedStrings = 0;\n\n        for (let fileName in allFileStrings) {\n            if (allFileStrings.hasOwnProperty(fileName)) {\n                if (fileName.endsWith('.csv')) {\n                    let strings = allFileStrings[fileName];\n                    updateTextProcessing(`Обробляємо та зберігаємо усі ID строк для файлу ${fileName}`);\n\n                    for (let string of strings) {\n                        promises.push(processingAllStringsTranslate(fileName, string.fileId, string.stringId, string.stringIdentifier, mainLocalizationArr).then(() => {\n                            completedStrings++;\n                            updateProgressBar(completedStrings, totalStrings); // Update progress bar\n                        }));\n                        if (promises.length >= MAX_CONCURRENT_REQUESTS) {\n                            await Promise.all(promises);\n                            promises.length = 0;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (promises.length > 0) {\n            await Promise.all(promises);\n        }\n\n        hideSpinner();\n    }\n\n    function saveJsonFile(mainLocalizationArr) {\n        updateProgressBar(100, 100);\n\n        const jsonObject = {\n            codes: [],\n            nodes: mainLocalizationArr\n        };\n\n        const jsonString = JSON.stringify(jsonObject, null, 2);\n        localStorage.setItem('mainLocalizationArr', jsonString); // Зберігаємо JSON в localStorage\n\n        // Зберігаємо дату та час збереження\n        const saveTime = new Date().toISOString();\n        localStorage.setItem('saveTime', saveTime);\n\n        // Створюємо Blob з JSON\n        const blob = new Blob([jsonString], {type: 'application/json'});\n        const fileUrl = URL.createObjectURL(blob);\n\n        // Завантажуємо файл локально\n        const a = document.createElement('a');\n        a.href = fileUrl;\n        a.download = 'Ukraine.json';\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n\n        URL.revokeObjectURL(fileUrl);\n\n        // Відправка JSON на сервер\n        uploadJsonToServer(blob);\n        check_json_file_exist(downloadButtonServerWrap, saveTime);\n\n        // Після завершення процесу генерації, показуємо посилання на завантаження файлу\n        if (downloadLink) {\n            let saveTimeTemp = localStorage.getItem('saveTime');\n            if (saveTimeTemp) {\n                document.getElementById('save-info-text').style.display = 'flex';\n                displaySaveTime(saveTimeTemp);\n            }\n            downloadLink.style.display = 'inline';\n            downloadButtonServer.style.display = 'block';\n        }\n    }\n\n    function downloadJsonFile() {\n        let savedJson = localStorage.getItem('mainLocalizationArr');\n        if (savedJson) {\n            const jsonObject = JSON.parse(savedJson);\n            const jsonString = JSON.stringify(jsonObject, null, 2);\n            const blob = new Blob([jsonString], {type: 'application/json'});\n            const url = window.URL.createObjectURL(blob);\n\n            const a = document.createElement('a');\n            a.href = url;\n            a.download = 'Ukraine.json';\n            document.body.appendChild(a);\n            a.click();\n            document.body.removeChild(a);\n\n            setTimeout(() => {\n                window.URL.revokeObjectURL(url);\n            }, 1000);\n        }\n    }\n\n    function uploadJsonToServer(blob) {\n        const formData = new FormData();\n        formData.append('file', blob, 'Ukraine.json');\n\n        fetch('/save-json.php', {\n            method: 'POST',\n            body: formData\n        })\n            .then(response => response.json())\n            .then(data => {\n                console.log('File successfully uploaded:', data);\n            })\n            .catch(error => {\n                console.error('Error uploading file:', error);\n            });\n    }\n\n    function check_json_file_exist(downloadButtonServerWrap, saveTime = false) {\n        let checkFileUrl = '/check-file.php';\n\n        if (saveTime) {\n            downloadButtonServerWrap.style.display = 'block';\n            downloadButtonServerWrap.querySelector('.txt-time')\n                .textContent = `Створено: ${new Date(saveTime).toLocaleString()}`;\n            return;\n        }\n\n        fetch(checkFileUrl)\n            .then(response => response.json())\n            .then(data => {\n                if (data.status === 'success') {\n                    // Якщо файл існує, показуємо кнопку\n                    downloadButtonServerWrap.style.display = 'block';\n                    // Додаємо дату та час створення файла до тексту кнопки\n                    downloadButtonServerWrap.querySelector('.txt-time')\n                        .textContent = `Створено: ${data.fileTime}`;\n                }\n            })\n            .catch(error => {\n                console.error('Error:', error);\n            });\n    }\n\n    // Перевірка наявності json файлу на сервері, та завантаження його по кліку\n    (function (downloadButtonServer, downloadButtonServerWrap) {\n        // URL для перевірки наявності файлу на сервері\n        const checkFileUrl = '/check-file.php';\n\n        // AJAX запит для перевірки наявності файлу\n        check_json_file_exist(downloadButtonServerWrap);\n\n        // Обробник події кліку для завантаження файлу\n        downloadButtonServer.addEventListener('click', function () {\n            fetch(checkFileUrl)\n                .then(response => response.json())\n                .then(data => {\n                    if (data.status === 'success') {\n                        // Якщо файл існує, завантажуємо його\n                        const downloadLink = document.createElement('a');\n                        downloadLink.href = '/json-local/Ukraine.json';\n                        downloadLink.download = 'Ukraine.json';\n                        document.body.appendChild(downloadLink);\n                        downloadLink.click();\n                        document.body.removeChild(downloadLink);\n                    } else {\n                        // Відображаємо повідомлення про відсутність файлу\n                        alert('Файл не знайдено на сервері.');\n                    }\n                })\n                .catch(error => {\n                    console.error('Error:', error);\n                });\n        });\n    })(downloadButtonServer, downloadButtonServerWrap);\n\n\n    if (downloadLink) {\n        downloadLink.addEventListener('click', function (event) {\n            event.preventDefault();\n            downloadJsonFile();\n        });\n    }\n\n    document.getElementById('generateBtn').addEventListener('click', function () {\n        startGeneration();\n    });\n})();\n\n//# sourceURL=webpack:///./src/js/main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/main.js");
/******/ 	
/******/ })()
;